const cds = require('../../cds')

const { getFrom } = require('../../../../lib/compile/for/flows')

const FLOW_STATUS = '@flow.status'
const FROM = '@from'
const TO = '@to'
// backwards compat
const FLOW_FROM = '@flow.from'
const FLOW_TO = '@flow.to'

function buildAllowedCondition(action, statusElementName, statusEnum) {
  const fromList = getFrom(action)
  const conditions = fromList.map(from => `${statusElementName} = '${statusEnum[from].val ?? from}'`)
  return `(${conditions.join(' OR ')})`
}

async function isCurrentStatusInFrom(req, action, statusElementName, statusEnum) {
  const cond = buildAllowedCondition(action, statusElementName, statusEnum)
  const parsedXpr = cds.parse.expr(cond)
  const dbEntity = await SELECT.one.from(req.subject).where(parsedXpr)
  return dbEntity !== undefined
}

async function checkStatus(req, action, statusElementName, statusEnum) {
  const allowed = await isCurrentStatusInFrom(req, action, statusElementName, statusEnum)
  if (!allowed) {
    const from = getFrom(action)
    req.reject({
      code: 409,
      message: from.length > 1 ? 'INVALID_FLOW_TRANSITION_MULTI' : 'INVALID_FLOW_TRANSITION_SINGLE',
      args: [action.name, statusElementName, from.join(',')]
    })
  }
}

/**
 * handler registration
 */
module.exports = cds.service.impl(function () {
  const entry = []
  const exit = []

  for (const entity of this.entities) {
    if (!entity.actions || !entity.elements) continue

    const fromActions = []
    const toActions = []
    for (const action of entity.actions) {
      if (action[FROM] || action[FLOW_FROM]) fromActions.push(action)
      if (action[TO] || action[FLOW_TO]) toActions.push(action)
    }
    if (fromActions.length === 0 && toActions.length === 0) continue

    let statusElement = Object.values(entity.elements).find(el => el[FLOW_STATUS])
    if (!statusElement) {
      cds.error(
        `Entity ${entity.name} does not have a status element, but its actions have registered @flow annotations.`
      )
    }

    let statusEnum, statusElementName
    if (statusElement.enum) {
      statusEnum = statusElement.enum
      statusElementName = statusElement.name
    } else if (statusElement?._target?.elements['code']) {
      statusEnum = statusElement._target.elements['code'].enum
      statusElementName = statusElement.name + '_code'
    } else {
      cds.error(
        `Status element in entity ${entity.name} is not an enum and does not have a valid target with code enum.`
      )
    }

    entry.push({ events: fromActions, entity, statusElementName, statusEnum })
    exit.push({ events: toActions, entity, statusElementName, statusEnum })
  }

  this.prepend(function () {
    for (const each of entry) {
      this.before(
        each.events,
        each.entity,
        Object.assign(
          async function handle_entry_state(req) {
            const action = req.target.actions[req.event]
            await checkStatus(req, action, each.statusElementName, each.statusEnum)
          },
          { _initial: true }
        )
      )
    }

    for (const each of exit) {
      async function handle_exit_state(req, next) {
        const res = await next()
        const action = req.target.actions[req.event]
        const to = action[TO] ?? action[FLOW_TO]
        const toKey = to['#'] ?? to['='] ?? to
        await UPDATE(req.subject).with({ [each.statusElementName]: each.statusEnum[toKey].val ?? toKey })
        return res
      }
      this.on(each.events, each.entity, handle_exit_state)
    }
  })
})
