// REVISIT: to be moved to cds-compiler later

const cds = require('../../..')

const FLOW_STATUS = '@flow.status'
const FROM = '@from'
const TO = '@to'
// backwards compat
const FLOW_FROM = '@flow.from'
const FLOW_TO = '@flow.to'

const getFrom = action => {
  let from = action[FROM] ?? action[FLOW_FROM]
  from = Array.isArray(from) ? from : [from]
  return from.map(f => f['#'] ?? f['='] ?? f)
}

function addOperationAvailableToActions(actions, statusEnum, statusElementName) {
  for (const action of Object.values(actions)) {
    const fromList = getFrom(action)
    const conditions = fromList.map(from => `$self.${statusElementName} = '${statusEnum[from].val ?? from}'`)
    const condition = `(${conditions.join(' OR ')})`
    const parsedXpr = cds.parse.expr(condition)
    action['@Core.OperationAvailable'] ??= {
      ...parsedXpr,
      ['=']: condition
    }
  }
}

function addSideEffectToActions(actions, statusElementName) {
  for (const action of Object.values(actions)) {
    const properties = []
    if (statusElementName.endsWith('.code')) {
      const baseName = statusElementName.slice(0, -5)
      properties.push(`in/${statusElementName}`)
      properties.push(`in/${baseName}/*`)
      properties.push(`in/${baseName}_code`)
    } else {
      properties.push(`in/${statusElementName}`)
    }
    const sideEffect = '@Common.SideEffects.TargetProperties'
    if (action[sideEffect]) {
      action[sideEffect].push(...properties)
    } else {
      action[sideEffect] = properties
    }
  }
}

function resolveStatusEnum(csn, codeElem) {
  if (codeElem.enum !== undefined) return codeElem.enum
  if (codeElem.type) {
    const typeDef = csn.definitions[codeElem.type]
    return typeDef ? typeDef.enum : undefined
  }
}

function enhanceCSNwithFlowAnnotations4FE(csn) {
  for (const definition of Object.values(csn.definitions)) {
    if (definition.kind !== 'entity') continue
    const entity = definition

    if (!entity.elements || !entity.actions) continue
    for (const [elemName, element] of Object.entries(entity.elements)) {
      if (!element[FLOW_STATUS]) continue

      const fromActions = []
      const toActions = []
      for (const action of Object.values(entity.actions)) {
        if (action[FROM] || action[FLOW_FROM]) fromActions.push(action)
        if (action[TO] || action[FLOW_TO]) toActions.push(action)
      }
      if (fromActions.length === 0 && toActions.length === 0) continue
      if (element.enum) {
        // Element is an enum directly
        addSideEffectToActions(toActions, elemName)
        addOperationAvailableToActions(fromActions, element.enum, elemName)
      } else if (element.target) {
        // Element is an association to a codelist
        const targetDef = csn.definitions[element.target]
        if (targetDef?.elements?.code) {
          const codeElem = targetDef.elements.code
          const statusEnum = resolveStatusEnum(csn, codeElem)
          if (statusEnum) {
            addSideEffectToActions(toActions, elemName + '.code')
            addOperationAvailableToActions(fromActions, statusEnum, elemName + '.code')
          }
        }
      } else if (element['@odata.foreignKey4']) {
        // when compiling to edmx, the foreign key is also annotated with @flow.status, but has no info about the target
        continue
      } else {
        cds.error(
          `Status element in entity ${entity.name} is not an enum and does not have a valid target with code enum.`
        )
      }
    }
  }
}

module.exports = { enhanceCSNwithFlowAnnotations4FE, getFrom }
